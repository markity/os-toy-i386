/* 上电后
 	1) 进入16位实模式, 此时只能访问1M内存
		(即使我们使用了.code16, 在打开A20地址线后, 还是能访问4G内存, 访问方法, 用32位寄存器存大的立即数, 然后用寄存器间接访问)
 	2) 跳转到BIOS(0xFFFF:0), 此处有一个jmp远跳转指令, 跳转到一个特殊的地方(取决于硬件), 进行BIOS自检,
		对主板硬盘, 显卡, 内存检查, 并保存一些配置数据到内存(此时会使用两块BIOS数据区), 如果一些关键设备自检失败, 那么无法启动
 	3) 检查磁盘0磁头(一个盘片两个面, 每面都有一个磁头, 可代指盘面)0磁道0扇区第511(0x55)字节和512字节标志(0xaa),
		判断磁盘是否为系统启动盘, 当有多块磁盘的时候, 对每个磁盘都进行检查,
		如果有多个启动选项的时候, 用户可进入bios调整, 选择进入哪个启动区
	4) 加载0磁道0扇区到0000:7c00处, 总计512字节的boot程序(0000:7c00~0000:7E00), 并跳转到cs=0:ip=0x7c00处执行代码,
		因为ip可跨度64kb, 因此完全足够, 不会发生指令回环现象
 */


 /* 实模式
	1) 16位代码(https://stackoverflow.com/questions/74603224/whats-the-difference-between-code16-and-code32)
		了解更多(流水线, cpu对指令的解释方式, 操作数大小和地址大小)
	2) 只能使用1MB内存(当你尝试使用32位的内存地址的时候会发生回环现象, https://bbs.pediy.com/thread-269223.htm)
	3) 寻址模式: 段地址 << 4 + 偏移地址
 */

/* 寄存器概览
	EAX EBX ECX EDX ESI EDI EBP ESP
	省略16位和8位的内部小寄存器
	CS DS SS ES FS GS
*/


/* 1M内存布局
00000 ~ 003FF	1KB				BIOS中断向量表
00400 ~ 004FF	256Byte			BIOS数据表
00500 ~ 7FFFF	511KB			自由使用区域可用区域, 500多KB
80000 ~ 9FFFF	128KB			拓展BIOS数据区

上面是640KB空间(LOW MEMORY)
启动机器的时候利用BIOS做很多工作, 当触发中断向量表的时候, BIOS例程接管机器
可用于执行一些BIOS调用实现很多功能, 因此除了中断向量表, BIOS两个数据区也应当好好保存, 不应该被用于存取数据

只有在进入32位模式之后, 不再调用BIOS中断后, 可用重用0x500之前的所有内容
因为即使进入32位模式之后, System Management Mode (SMM) 仍然是开启, 会用到这些内存, 因此拓展BIOS数据不应被重写!!
------
下面是384KB系统保留内存

A0000 ~ BFFFF   128kb   分配给外围设备的内存映射, 比如显存B8000~B8FA0为显存
下面全是BIOS ROM代码内存
C0000 ~ FFFFF
*/


/* gcc编译汇编的独特操作, 允许定义符号 */
#include "comm/info.h"
/*生成16位代码*/
.code16
/* 标识代码段 */
.text
/* 导出_start, 以便链接的时候符号能被其它文件找到 */
.global _start
	/* 工作: 将所有段地址置零, 设置栈ip指向0x7c00 */
_start:
	/*体会一下16位模式下操作数只可以是32位的情况*/
	/*
	mov $0, %eax
	mov $0x1000000, %eax
	mov $0x1000000, %ax
	*/

	/*体会一个地址不可以为32位的情况*/
	/*
	mov 0x10000000, %eax
	*/
	/*但是可以用寄存器间接访问*/
	/*
	mov $0x10000000, %eax
	mov (%eax), %eax
	*/

	/* 等价于mov $0, %ax */
	xor %ax, %ax
	mov %ax, %ds
	mov %ax, %ss
	mov %ax, %es
	mov %ax, %fs
	mov %ax, %gs

	/* AT&T汇编将目的操作数放在后面 */
	/* 设置栈, 供boot和loader使用, 已知0x7c000前有30K的内存可以使用*/
	mov $_start, %sp

	/* 使用int0x10软中断实现字符打印
		ah = 0xe(功能码)	al = ASCII码
		bl = 前景色			bh = 目前显示页
		在图形模式BH必须为0, 我们现在只讨论文字模式
		0xe是显示字符的功能码, 光标随字符移动
		TODO 探究前景色和显示页的写法
	*/
	/* mov $0xe,%ah
	 	mov $'!',%al
	 	mov $0x0,%bl
	 	mov $0, %bh
		int $0x10
	*/


/* 工作: 加载0扇区后面的几个扇区, 为loader, loader加载到0x8000 */
read_loader:

	/* int 0x13磁盘读取
	入参
		AH = 02H 标识服务号, 读磁盘
		AL = 读取扇区的数目
		CH = 柱面
		CL = 第一个读取扇区的索引
		DH = 磁头
		DL = 驱动器, 00H-0FH软盘 80H~0FFH硬盘
		ES:BX=目的地址
	出参
		CF = 0 AH = 0 AL=传输的扇区数 操作成功
		CF != 0 AH = 状态码 操作失败
	*/

	/* 之前es已经为0了, 我们需要把东西读入到0:0x8000 */
	mov $0x8000, %bx
	/* 指明为2号服务, 读取64个扇区, 共计64*512个字节, 足够存放loader, 最大读到0xFFFF处, 刚好64*512字节, 妙啊 */
	mov $0x2, %ah
	mov $64, %al
	/* 一步到位, 0号柱面, 2号扇区开始, 注意BIOS认为扇区从1开始计数 */
	mov $0x2, %cx
	/* 磁头0, 驱动器80 */
	mov $0x0080, %dx
	/* TODO 细说驱动器怎么排的?? */
	/* 执行中断调用 */
	int $0x13
	/* 除了重试, 好像没有更好的写法, 只能不断重试 */
	jc read_loader

	/* 从start.S 跳转进入boot.c代码 */
	jmp LOADER_ADDR

	/* space, 用0填充, 用.org也行的 */
	.space 510-(.-_start)
	.byte 0x55, 0xaa